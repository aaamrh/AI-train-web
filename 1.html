<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>

  <style>
  body{
    background: #000;
  }

  #canvas{
    background: #eee;
  }
  </style>
</head>
<body>
  <canvas id='canvas' height="800" width="1500">
    哥,你的浏览器太旧了
  </canvas>


  <script src="./utils/utils.js"></script>
  <script src="./tools.js"></script>
  <script src="./components/box.js"></script>
  <script>
    /** 
     *  STATE 设置: dragOrLine()
     *    鼠标点下: 如果在box上: 拖拽（isDrag）
     *             如果在knot上: 画线（isDrawLine）
     * 
     *  STATE 还原：
     *    doc鼠标抬起: mosdown = false, mosup = true
     *                isDrag = false, STATE.isDrawLine = false;
     *                O.optBox = null, O.optKnot = null;
    */


    let cv = document.getElementById('canvas');
    let ctx = cv.getContext('2d');
    // 获取鼠标在canvas上的坐标
    let mousePos = T.getMousePos(cv)
    
    let O = {
      boxes:[],
      knots: [],
      hoverBox:null,
      hoverKnot:null,
      optBox: null,
      optKnot: null,
    }
    let STATE = {
      mosdown:false,
      mosup:true,
      isDrag: false,
      isDrawLine: false,
    }
  
    let box1 = new TitleBox({x:100, y:100})
    let box2 = new Box({x:150, y:150, topBg:'red'})
    let box3 = new Box({x:200, y:200, topBg:'pink'})
    let box4 = new Box({x:250, y:250, topBg:'yellow'})
    let box5 = new Box({x:300, y:300, topBg:'orange'})


    O.boxes.push(box1)
    O.boxes.push(box2)
    O.boxes.push(box3)
    O.boxes.push(box4)
    O.boxes.push(box5)


    /** 
     * 1. 鼠标点下， 判断是拖拽还是连线  
     * 2. 鼠标移动， 拖拽 || 连线
    */
    cv.addEventListener('mousedown', (ev)=>{
      STATE.mosdown = true;
      STATE.mosup = false;

      let posOnObj = isMouseOnObj();
      if(!posOnObj) {return}

      let knotActive = isPointKnot(mousePos)
      if( knotActive ){ O.optKnot = O.hoverBox.knots[knotActive.name] }
      

      //  设置 STATE: drag drawLine
      if(posOnObj){ dragOrLine( posOnObj ) }                  // 1
      let opts = options(posOnObj)

      cv.addEventListener('mousemove', opts)
      cv.addEventListener('mouseup', ()=>{
        cv.removeEventListener('mousemove', opts)
      })
    })  // mousedown END
   

   
    document.addEventListener('mouseup', ()=>{ 
      STATE.mosdown = false;
      STATE.mosup = true;

      STATE.isDrag = false;
      STATE.isDrawLine = false; 

      O.optBox = null;
      O.optKnot = null;
    })

    cv.addEventListener('mouseup', ()=>{
      // TODO:
      // 判断 是否在 节点上, 如果是就创建一条线
      // 判断结束时 hover 的节点 与 操作节点是否相同
      // 吸附功能

      // O.optKnot.start = {
      //   x: O.optKnot.x,
      //   y: O.optKnot.y
      // }
      // O.optKnot.end = {
      //   endX: mousePos.x,
      //   endY: mousePos.y
      // }
    })


    cv.addEventListener('mousemove', function(){
      // BUG: 拖拽时，鼠标移动过快会丢失 hoverbox
      console.log('------')
      console.log(O.hoverBox)
      console.log(O.optBox)
      console.log(O.hoverKnot)
      console.log(O.optKnot)
      if( isMouseOnObj() ){
        O.hoverBox.transform({ ishover: true })

        let actKnot = isPointKnot(mousePos);
        setKnotStyle(actKnot)
        refresh()
        if( !actKnot ){ O.hoverKnot = null }
      }else{
        O.hoverBox = null;
        O.hoverKnot = null;
      }
    })

    
    /**
     * 鼠标是否在 obj 上
     * 如果在：修改 O.obj,  STATE.isDrag
     * @return {鼠标在obj上的位置|false} 
     * NOTICE: 这里设置 O.obj,  O.knot
     * 
     * （移动 && 点击） 都会判断 mos是否在对象上
     */
    function isMouseOnObj(){
      let result;
      let num = 0;

      for(let i=O.boxes.length-1; i>=0; i--){

        O.boxes[i].transform({ ishover:false })
       
        if( O.boxes[i].isPoint(mousePos) ){  // 鼠标在box上
          // 鼠标在多个box重合的地方时，所有的box会都有边框,因此只设置第一个box的hover状态(num == 0)
          if(num == 0){
            if(STATE.mosdown){  // 第一次点击（不拖拽，不画线）时设置 optBox
              if( !STATE.isDrag && !STATE.isDrawLine ) { 
                O.optBox = O.boxes[i] 
              };
            }
            O.hoverBox = O.boxes[i];
            O.hoverBox.transform({ ishover: true });
            num++;
          }

          result = getPosOnObj()
        }
      }
      refresh()

      if(!result){ return false }
      return result;
    }  // isMouseOnObj  END

    
    /**
     * 获取鼠标在 obj 上的坐标
     */
    function getPosOnObj(){
      let pos = {};
      pos.x = mousePos.x - O.hoverBox.x;
      pos.y = mousePos.y - O.hoverBox.y;
      return pos
    }


    function isPointKnot(pos){
      // 鼠标是否在 连接点 上, 是返回该 knot，不是返回 false
      return O.hoverBox.isPointKnot(pos)
    }


    function setKnotStyle(knot){
      // 设置 knot 的 hover 样式
      if( knot ){
        knot.fillStyle = 'red';
        // 节点对应的box存储到 knots ： {'left-knot': Box1}
        O.knots[ knot.name ] = O.hoverBox;
        O.hoverKnot = O.hoverBox.knots[knot.name];
      }else{
        // O.hoverKnot = null;
        for(let name in O.knots){
          let box = O.knots[name];
          box.knots[name].fillStyle = '#333';
        }
      }
    }


    function dragOrLine(o){
      // 拖拽: 鼠标点击对象 && 不在连接点上 
      if( o && !STATE.isDrawLine ){ STATE.isDrag = true }

      // 如果点击在 knot 上不是拖动， 是连线
      if( isPointKnot(mousePos) ){  
        STATE.isDrag = false;
        STATE.isDrawLine = true; 
      }
    }

        
    function refresh(){
      ctx.clearRect(0, 0, cv.width, cv.height);
      O.boxes.forEach( item => item.draw() )
    }


    function options(posOnObj){
      return function(){          // 2
        if(STATE.isDrag){                       
          O.optBox.transform({
            x: mousePos.x - posOnObj.x,
            y: mousePos.y - posOnObj.y
          })
          refresh()
        }

        // TODO: 画线
        // 1. 鼠标抬起， 如果在另一个点上，建立连线
        // 2. 链接线的存储的信息： （box1, box2, knot-left || ..., 起始坐标）
        // 3. 连接点的坐标 应该根据：box移动后的 起点 和 终点的坐标变化
        if(STATE.isDrawLine){
          O.optBox.linePath({
            startX: O.optKnot.x,
            startY: O.optKnot.y,
            endX: mousePos.x,
            endY: mousePos.y
          })
        }
      }
    }

    
   


    /*
      var yImg = new Image();
      yImg.src = './arcTo.png';
      yImg.onload = function(){
        draw(this)
      }
      function draw(obj){
        ctx.drawImage(obj, 100, 50) 
      }
    
    */

  </script>
</body>
</html>